//
//  SubscribeEvent.swift
//
//
//  This file was auto-generated by Fern from our API Definition.
//

import Foundation


public enum SubscribeEvent: Decodable {
    case assistantEnd(AssistantEnd)
    case assistantMessage(AssistantMessage)
    case audioOutput(AudioOutput)
    case chatMetadata(ChatMetadata)
    case webSocketError(WebSocketError)
    case userInterruption(UserInterruption)
    case userMessage(UserMessage)
    case toolCallMessage(ToolCallMessage)
    case toolResponseMessage(ToolResponseMessage)
    case toolErrorMessage(ToolErrorMessage)
    
    
    private enum CodingKeys: String, CodingKey {
        case type
    }
    
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "assistant_end":
            self = .assistantEnd(try AssistantEnd(from: decoder))
        case "assistant_message":
            self = .assistantMessage(try AssistantMessage(from: decoder))
        case "audio_output":
            self = .audioOutput(try AudioOutput(from: decoder))
        case "chat_metadata":
            self = .chatMetadata(try ChatMetadata(from: decoder))
        case "error":
            self = .webSocketError(try WebSocketError(from: decoder))
        case "user_interruption":
            self = .userInterruption(try UserInterruption(from: decoder))
        case "user_message":
            self = .userMessage(try UserMessage(from: decoder))
        case "tool_call":
            self = .toolCallMessage(try ToolCallMessage(from: decoder))
        case "tool_response":
            self = .toolResponseMessage(try ToolResponseMessage(from: decoder))
        case "tool_error":
            self = .toolErrorMessage(try ToolErrorMessage(from: decoder))
        default:
            throw HumeError.invalidType(type)
        }
    
    }
}
